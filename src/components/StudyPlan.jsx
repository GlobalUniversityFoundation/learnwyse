import { useState, useMemo, useEffect } from 'react'
import './StudyPlan.css'

function StudyPlanComponent({ student, onBack }) {
  const [examDate, setExamDate] = useState('')
  const [timetable, setTimetable] = useState([])
  const [showSuccess, setShowSuccess] = useState(false)
  const [isAutoGenerated, setIsAutoGenerated] = useState(false)

  const subjects = ['Mathematics', 'Science', 'Social Studies', 'English']
  
  const conceptsBySubject = {
    'Mathematics': [
      'Basic Operations', 
      'Fractions and Decimals', 
      'Algebraic Expressions', 
      'Linear Equations', 
      'Quadratic Equations',
      'Geometry Basics',
      'Triangles and Angles',
      'Circles',
      'Trigonometry',
      'Statistics and Probability'
    ],
    'Science': [
      'Water Cycle',
      'Photosynthesis',
      'Cell Structure',
      'States of Matter',
      'Force and Motion',
      'Electricity and Magnetism',
      'Chemical Reactions',
      'Ecosystems',
      'Solar System',
      'Human Body Systems'
    ],
    'Social Studies': [
      'Ancient Civilizations',
      'Medieval Period',
      'Renaissance',
      'World Wars',
      'Indian Independence',
      'State Government',
      'Democracy',
      'Maps and Geography',
      'Climate and Weather',
      'Economic Systems'
    ],
    'English': [
      'Parts of Speech',
      'Sentence Structure',
      'Tenses',
      'Reading Comprehension',
      'Creative Writing',
      'Poetry',
      'Short Stories',
      'Grammar Rules',
      'Vocabulary Building',
      'Essay Writing'
    ]
  }

  const daysUntilExam = useMemo(() => {
    if (!examDate) return 0
    const today = new Date()
    const exam = new Date(examDate)
    const diffTime = exam - today
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
    return diffDays > 0 ? diffDays : 0
  }, [examDate])

  // Generate study plan based on performance metrics
  const generateStudyPlan = (days) => {
    if (!student?.masteryData || days <= 0) return []
    
    const newTimetable = []
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    
    // Create empty days
    for (let i = 0; i < days; i++) {
      const dayDate = new Date(today)
      dayDate.setDate(today.getDate() + i)
      newTimetable.push({
        day: i + 1,
        date: dayDate.toISOString().split('T')[0],
        entries: []
      })
    }
    
    // Analyze mastery data to prioritize subjects
    const subjectPriorities = student.masteryData
      .map(item => ({
        subject: item.subject,
        mastery: item.percentage,
        status: item.status,
        priority: item.status === 'Need Practice' ? 3 : item.status === 'Need Review' ? 2 : 1
      }))
      .sort((a, b) => b.priority - a.priority || a.mastery - b.mastery)
    
    // Get concepts for each subject
    const subjectConcepts = {}
    subjectPriorities.forEach(({ subject }) => {
      subjectConcepts[subject] = getAvailableConcepts(subject)
    })
    
    // Calculate total study sessions needed (2-3 sessions per day)
    const sessionsPerDay = days <= 7 ? 3 : days <= 14 ? 2.5 : 2
    const totalSessions = Math.floor(days * sessionsPerDay)
    
    // Distribute sessions based on priority and mastery
    const sessionPlan = []
    subjectPriorities.forEach(({ subject, mastery, priority }) => {
      const concepts = subjectConcepts[subject] || []
      if (concepts.length === 0) return
      
      // Calculate sessions for this subject
      let sessionsForSubject
      if (mastery < 50) {
        sessionsForSubject = Math.ceil(totalSessions * 0.35) // 35% for weak subjects
      } else if (mastery < 75) {
        sessionsForSubject = Math.ceil(totalSessions * 0.30) // 30% for moderate subjects
      } else {
        sessionsForSubject = Math.ceil(totalSessions * 0.20) // 20% for strong subjects
      }
      
      // Distribute concepts across sessions
      for (let i = 0; i < sessionsForSubject && i < concepts.length * 2; i++) {
        const conceptIndex = Math.floor(i / 2) % concepts.length
        const concept = concepts[conceptIndex]
        
        // Determine study time based on mastery
        let timeAllocation = '1 hr'
        if (mastery < 50) {
          timeAllocation = ['1.5 hrs', '2 hrs'][i % 2]
        } else if (mastery < 75) {
          timeAllocation = ['1 hr', '1.5 hrs'][i % 2]
        } else {
          timeAllocation = ['30 mins', '1 hr'][i % 2]
        }
        
        sessionPlan.push({
          subject,
          concept,
          time: timeAllocation,
          priority,
          mastery
        })
      }
    })
    
    // Sort sessions by priority (higher priority first)
    sessionPlan.sort((a, b) => {
      if (b.priority !== a.priority) return b.priority - a.priority
      return a.mastery - b.mastery // Lower mastery first within same priority
    })
    
    // Distribute sessions across days evenly
    const daysWithSessions = new Set()
    sessionPlan.forEach((session, index) => {
      // Distribute evenly, but avoid clustering
      const dayIndex = Math.floor((index * days) / sessionPlan.length)
      const actualDayIndex = Math.min(dayIndex, days - 1)
      
      // Ensure we don't exceed 3 sessions per day
      if (!newTimetable[actualDayIndex].entries || newTimetable[actualDayIndex].entries.length < 3) {
        if (!newTimetable[actualDayIndex].entries) {
          newTimetable[actualDayIndex].entries = []
        }
        newTimetable[actualDayIndex].entries.push({
          subject: session.subject,
          concept: session.concept,
          time: session.time
        })
        daysWithSessions.add(actualDayIndex)
      } else {
        // Find next available day
        for (let d = 0; d < days; d++) {
          const checkDay = (actualDayIndex + d) % days
          if (newTimetable[checkDay].entries.length < 3) {
            newTimetable[checkDay].entries.push({
              subject: session.subject,
              concept: session.concept,
              time: session.time
            })
            daysWithSessions.add(checkDay)
            break
          }
        }
      }
    })
    
    // Add review sessions for subjects with mastery < 75 (spaced repetition)
    subjectPriorities.forEach(({ subject, mastery }) => {
      if (mastery < 75) {
        const concepts = subjectConcepts[subject] || []
        if (concepts.length === 0) return
        
        // Add review sessions every 3-4 days
        const reviewInterval = Math.max(3, Math.floor(days / 4))
        for (let day = reviewInterval; day < days; day += reviewInterval) {
          if (newTimetable[day].entries.length < 3) {
            // Review first concept from this subject
            const reviewConcept = concepts[0]
            newTimetable[day].entries.push({
              subject,
              concept: reviewConcept,
              time: '30 mins'
            })
          }
        }
      }
    })
    
    // Sort entries within each day by priority
    newTimetable.forEach(day => {
      day.entries.sort((a, b) => {
        const aData = student.masteryData.find(m => m.subject === a.subject)
        const bData = student.masteryData.find(m => m.subject === b.subject)
        const aMastery = aData?.percentage || 50
        const bMastery = bData?.percentage || 50
        const aPriority = aData?.status === 'Need Practice' ? 3 : aData?.status === 'Need Review' ? 2 : 1
        const bPriority = bData?.status === 'Need Practice' ? 3 : bData?.status === 'Need Review' ? 2 : 1
        
        if (bPriority !== aPriority) return bPriority - aPriority
        return aMastery - bMastery
      })
    })
    
    return newTimetable
  }

  const handleExamDateChange = (e) => {
    const date = e.target.value
    setExamDate(date)
    setIsAutoGenerated(false)
    
    if (date) {
      const today = new Date()
      today.setHours(0, 0, 0, 0)
      const exam = new Date(date)
      exam.setHours(0, 0, 0, 0)
      const diffTime = exam - today
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
      
      if (diffDays > 0) {
        // Auto-generate study plan
        const generatedPlan = generateStudyPlan(diffDays)
        setTimetable(generatedPlan)
        setIsAutoGenerated(true)
      } else {
        setTimetable([])
        setIsAutoGenerated(false)
      }
    } else {
      setTimetable([])
      setIsAutoGenerated(false)
    }
  }
  
  // Regenerate study plan button handler
  const handleRegeneratePlan = () => {
    if (examDate && daysUntilExam > 0) {
      const generatedPlan = generateStudyPlan(daysUntilExam)
      setTimetable(generatedPlan)
      setIsAutoGenerated(true)
    }
  }

  const addTimetableEntry = (dayIndex) => {
    const newTimetable = [...timetable]
    newTimetable[dayIndex].entries.push({
      subject: '',
      concept: '',
      time: ''
    })
    setTimetable(newTimetable)
  }

  const updateTimetableEntry = (dayIndex, entryIndex, field, value) => {
    const newTimetable = [...timetable]
    newTimetable[dayIndex].entries[entryIndex][field] = value
    setTimetable(newTimetable)
  }

  const removeTimetableEntry = (dayIndex, entryIndex) => {
    const newTimetable = [...timetable]
    newTimetable[dayIndex].entries.splice(entryIndex, 1)
    setTimetable(newTimetable)
  }

  const handleReleaseStudyPlan = () => {
    // Show success message
    setShowSuccess(true)
    
    // Navigate back after 2 seconds
    setTimeout(() => {
      if (onBack) {
        onBack()
      }
    }, 2000)
  }

  const getAvailableConcepts = (subject) => {
    return conceptsBySubject[subject] || []
  }

  const getMinDate = () => {
    const tomorrow = new Date()
    tomorrow.setDate(tomorrow.getDate() + 1)
    return tomorrow.toISOString().split('T')[0]
  }

  return (
    <>
      {showSuccess && (
        <div className="success-overlay">
          <div className="success-modal">
            <div className="success-checkmark">
              <svg className="checkmark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                <circle className="checkmark-circle" cx="26" cy="26" r="25" fill="none"/>
                <path className="checkmark-check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
              </svg>
            </div>
            <h2 className="success-title">Study Plan Released!</h2>
            <p className="success-message">The study plan has been successfully created and shared with {student.name}</p>
          </div>
        </div>
      )}
      <div className="study-plan-container">
        <div className="study-plan-header">
          <div className="exam-date-selector">
            <label htmlFor="exam-date" className="exam-date-label">Select Exam Date:</label>
            <input
              type="date"
              id="exam-date"
              className="exam-date-input"
              value={examDate}
              onChange={handleExamDateChange}
              min={getMinDate()}
            />
          </div>
          {daysUntilExam > 0 && (
            <div className="days-until-exam">
              <span className="days-label">Days until exam:</span>
              <span className="days-count">{daysUntilExam}</span>
            </div>
          )}
        </div>
        
        {isAutoGenerated && timetable.length > 0 && (
          <div className="auto-generated-banner">
            <div className="banner-content">
              <span className="banner-icon">✨</span>
              <span className="banner-text">Study plan auto-generated based on {student.name}'s performance metrics</span>
            </div>
            <button className="regenerate-button" onClick={handleRegeneratePlan}>
              Regenerate Plan
            </button>
          </div>
        )}

      {timetable.length > 0 && (
        <div className="timetable-container">
          <h3 className="timetable-title">Study Timetable</h3>
          <div className="timetable-days">
            {timetable.map((day, dayIndex) => (
              <div key={dayIndex} className="timetable-day">
                <div className="day-header">
                  <h4 className="day-title">Day {day.day}</h4>
                  <span className="day-date">{new Date(day.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</span>
                  <button 
                    className="add-entry-button"
                    onClick={() => addTimetableEntry(dayIndex)}
                  >
                    + Add Entry
                  </button>
                </div>
                
                <div className="day-entries">
                  {day.entries.map((entry, entryIndex) => (
                    <div key={entryIndex} className="timetable-entry">
                      <select
                        className="entry-select entry-subject"
                        value={entry.subject}
                        onChange={(e) => updateTimetableEntry(dayIndex, entryIndex, 'subject', e.target.value)}
                      >
                        <option value="">Select Subject</option>
                        {subjects.map((subject) => (
                          <option key={subject} value={subject}>{subject}</option>
                        ))}
                      </select>
                      
                      <select
                        className="entry-select entry-concept"
                        value={entry.concept}
                        onChange={(e) => updateTimetableEntry(dayIndex, entryIndex, 'concept', e.target.value)}
                        disabled={!entry.subject}
                      >
                        <option value="">Select Concept</option>
                        {entry.subject && getAvailableConcepts(entry.subject).map((concept) => (
                          <option key={concept} value={concept}>{concept}</option>
                        ))}
                      </select>
                      
                      <select
                        className="entry-select entry-time"
                        value={entry.time}
                        onChange={(e) => updateTimetableEntry(dayIndex, entryIndex, 'time', e.target.value)}
                      >
                        <option value="">Select Duration</option>
                        <option value="30 mins">30 mins</option>
                        <option value="1 hr">1 hr</option>
                        <option value="1.5 hrs">1.5 hrs</option>
                        <option value="2 hrs">2 hrs</option>
                        <option value="2.5 hrs">2.5 hrs</option>
                        <option value="3 hrs">3 hrs</option>
                        <option value="3.5 hrs">3.5 hrs</option>
                        <option value="4 hrs">4 hrs</option>
                      </select>
                      
                      <button
                        className="remove-entry-button"
                        onClick={() => removeTimetableEntry(dayIndex, entryIndex)}
                      >
                        ×
                      </button>
                    </div>
                  ))}
                  
                  {day.entries.length === 0 && (
                    <div className="empty-day-message">
                      No entries yet. Click "Add Entry" to add study sessions.
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {timetable.length > 0 && (
        <div className="study-plan-actions">
          <button className="release-study-plan-button" onClick={handleReleaseStudyPlan}>
            Release Study Plan
          </button>
        </div>
      )}
      </div>
    </>
  )
}

export default StudyPlanComponent

